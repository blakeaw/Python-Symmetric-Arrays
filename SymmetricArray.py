"""Some simple symmetric array classes

This module defines two symmetric array classes, SymmetricArray (NxN) and SymmetricArray3d (NxNxN),
which are meant to be used in place of numpy arrays where the arrays they 
represent have symmetric elements (i.e. they have the same value in array). These 
symmetric arrays classes only store the unique values of the array and therefore use 
just over half the memory of the full numpy array version. However, the specially defined
indexing functions allow interchangeable use of the symmetric indices during getting and setting of
the elements. 
E.g. a SymmetricArray(10) object (representing a 10x10 symmetric array) 
stores the (10**2 + 10)/2 = 55 unique values instead of the full 100.  

I'm not sure if there may ever be a time when anyone would
want to store custom objects in this type of symmetric array sturcture, but 
there are also two helper functions which can be used
to build lists of objects. These fucntions could be
passed to the symmetric arrays in place of the numpy array builders to 
store instances of custom objects.

 
Examples:
    >>> import SymmetricArray as symarr
    >>> sym_array_a = symarr.SymmetricArray(10)
    >>> print sym_array_a
    Representation of a 10x10 array where array[i,j] = array[j,i] with 55 unique values.
    >>> sym_array_a[1, 9] = 1.0
    >>> print sym_array_a[9, 1]
    1.0
        
    >>> sym_array_b = symarr.SymmetricArray3d(10)
    >>> print sym_array_b
    Representation of a 10x10x10 array where array[i,j,k] = array[j,i,k] with 550 unique values.
    >>> 
    >>> sym_array_b[1, 9, 2] = 5.0
    >>> print sym_array_a[9, 1, 2]
    5.0
    
    >>> import numpy as np
    >>> sym_array_c = symarr.SymmetricArray(10, np.full, 5, dtype=np.int)
    >>> print sym_array_c[1,5]
    5
    >>> print sym_array_c[5,1]
    5
    >>> print sym_array_c.dtype
    <type 'numpy.int64'>
    >>> print sym_array_c.unique
    55
    >>> print sym_array_c[0,11]
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "SymmetricArray.py", line 119, in __getitem__
        return
    IndexError: Index 11 is out of range.

    >>> print sym_array_c[5,-1]
    5
    >>> sym_array_c[5, 9] = 6
    >>> print sym_array_c[5,-1]
    6

    


"""

#imports

#NumPy -- http://www.numpy.org/
# used without modification. 
import numpy as np

# NxN symmetric array
class SymmetricArray:
    """ NxN symmetric array object    
    An array object for the case of NxN array where a[i,j] = a[j,i]. An array of this
    will have (N**2 + N)/2 unique values, which is a little over half the total values 
    in the full NxN array. This class takes advantage of this by essentially building 
    a triangle matrix with only the unique values.  
                    
    """
    def __init__(self, N, fill_function=np.zeros, *args, **kwargs):
        """ Initialization of the SymmetricArray object.  

            Args:
                N (int): Defines the shape of the array, i.e. NxN.   
                fill_function (array generator, optional): Set the array generator function to use to
                    fill the array.  The default is numpy.zeros, which will fill the array with numpy.double zeros.
                    Other options include numpy.full and numpy.random.random. Other non-numpy functions could be used,
                    but the input function must accept at least one argument, which is an integer array length.
                    Additional arguments can be passed to the fill_function via args and kwargs. 
                args (optional): Additional arguments to be passed to the fill_function
                kwargs (optional): Additional keyword arguments to be passed to the fill_function.
            
            Attributes:
                unique (int): The number of unique elements in the array.
                shape (tuple): A tuple containing the shape that this array represents. 
                    Note that this is not the true shape of the underlying structure. 
                N (int): Defines the shape of the array, i.e. NxN
                values (list): A list which serves as the outer structure of the triangle array
                    used to hold the unique elements. Each element of this list is an array of the type
                    generated by the fill_function. 
                sm1 (int): This is just to store N-1 which is used in for key checking.
                dtype (data type): The type of the data in the array. Uses the type function
                    to get the data type after calling of fill_function is done.  
        """
        self.unique = (N**2 + N)/2
        self.shape = (N, N)
        self.N = N
        self.values = []
        self.sm1 = N-1
        for i in xrange(N):
            self.values.append(fill_function((N-i), *args, **kwargs ))
        
        self.dtype = type(self.values[0][0])
        
        return

    def __getitem__(self, keys):
        """ Get the element at the indices given in the input keys tuple.
            This function ultimately calls the non-builtin getitem function. 
            
            Args:
                keys (tuple of int): A tuple of two integer indices for
                    for the element being indexed.
            Returns:
                value (self.dtype): The element in array at the given indices. 
            
            Raises:
                IndexError: If keys is not a tuple (or list) of length two, or if
                    the supplied indices are out of range. 
            Notes:
                Supports negative indexing. Does not support slicing.         

        """    
        if not (isinstance(keys, tuple) or isinstance(keys, list)):
            raise IndexError('Index '+str(keys)+' has the wrong number of keys.')
            return
        elif len(keys) != 2:
            raise IndexError('Index '+str(keys)+' has the wrong number of keys.')
            return
       
        for key in keys:
            if (key > self.sm1) or (key < -self.N):
                raise IndexError('Index '+str(key)+' is out of range.')
                return
                
        value = self.getitem(keys[0], keys[1])
        return value
        
    def __setitem__(self, keys, value):
        """ Set the element at the indices given in the input keys tuple.
            This function ultimately calls the non-builtin setitem function. 
            
            Args:
                keys (tuple of int): A tuple of two integer indices for
                    for the element being indexed.
            Returns:
                void
            Raises:
                IndexError: If keys is not a tuple (or list) of length two, or if
                    the supplied indices are out of range. 
            Notes:
                Supports negative indexing. Does not support slicing.         

        """    
        if not (isinstance(keys, tuple) or isinstance(keys, list)):
            raise IndexError('Index '+str(keys)+' has the wrong number of keys.')
            return
        elif len(keys) != 2:
            raise IndexError('Index '+str(keys)+' has the wrong number of keys.')
            return
        for key in keys:
            if (key > self.sm1) or (key < -self.N):
                raise IndexError('Index '+str(key)+' is out of range.')
                return

        self.setitem(keys[0], keys[1], value)
        return

    def getitem(self, keya, keyb):
        """ Get the element at the indices given in the input keys.
            This function is called the builtin __getitem__ function. 
            
            Args:
                keya (int): The integer row index of the element.
                keyb (int): The integer column index of the element.
            Returns:
                value (self.dtype): The element in array at the given keys/indices. 
            
            Raises:
                IndexError: If keys is not a tuple (or list) of length two, or if
                    the supplied indices are out of range. 
            Notes:
                Supports negative indexing. Does not support slicing.         

        """   
        if (keya > self.sm1) or (keya < -self.N):
            raise IndexError('Index '+str(keya)+' is out of range.')
            return
        elif (keyb > self.sm1) or (keyb < -self.N):
            raise IndexError('Index '+str(keyb)+' is out of range.')
            return
        if keya < 0:
            keya+=self.N
        if keyb < 0:
            keyb+=self.N
        key_arr = [keya, keyb]
        mink = min(key_arr)
        maxk = max(key_arr)
        return self.values[mink][maxk-mink]

    def setitem(self, keya, keyb, value):
        """ Set the element at the indices given in the input keys.
            This function is called by the builtin __setitem__ function. 
            
            Args:
                keya (int): The integer row index of the element.
                keyb (int): The integer column index of the element.
            Returns:
                void
            Raises:
                IndexError: If keys is not a tuple (or list) of length two, or if
                    the supplied indices are out of range. 
            Notes:
                Supports negative indexing. Does not support slicing.         

        """    
        if (keya > self.sm1):
            raise IndexError('Index '+str(keya)+' is out of range.')
            return
        elif (keyb > self.sm1):
            raise IndexError('Index '+str(keyb)+' is out of range.')
            return
        if keya < 0:
            keya+=self.N
        if keyb < 0:
            keyb+=self.N
        key_arr = [keya, keyb]
        mink = min(key_arr)
        maxk = max(key_arr)
        self.values[mink][maxk-mink] = value
        return

    # basic += to add some constant value to all elements
    def __iadd__(self, value):
        if isinstance(value, SymmetricArray):
            if self.N != value.N:
                raise ValueError('Symmetric arrays must be of the same shape for this operation.')
                return
            elif self.dtype != value.dtype:
                raise TypeError('Symmetric arrays must contain the same data type for this operation.')
                return
            #passed some error checking, so try adding
            for i in xrange(self.N-1):
                for j in xrange(i+1, self.N):
                    self[i, j] = self[i, j] + value[i, j] 
            return
        elif isinstance(value, self.dtype):
            #okay value is of the data type contained in this instance of SymmetricArray, so try adding  
            for i in xrange(self.N-1):
                for j in xrange(i+1, self.N):
                    self[i, j] = self[i, j] + value 
            return
        else:
            #not sure what the input is, so lets just try element wise addition and see if is compatible
            try:
                for i in xrange(self.N-1):
                    for j in xrange(i+1, self.N):
                        self[i, j] = self[i, j] + value
            except:
                raise TypeError('Cannot add the input to SymmetricArray array object.')                 
        return
        
    #build and return the full NxN numpy array version
    def full_numpy(self):
        """ Get the full NxN numpy array from the SymmetricArray. 
            
            Args:
                void
            Returns:
                outarr (numpy.array): The full NxN numpy array version of this instance of SymmetricArray. 
            Raises:
                NONE 
            Notes:
                This function will only work if self.dtype is a numpy supported data type.         

        """    
        outarr = np.zeros((self.N, self.N), dtype=self.dtype)
        for i in xrange(self.N-1):
            for j in xrange(i+1, self.N):
                value = self[i, j] 
                outarr[i][j] = value
                outarr[j][i] = value
        return outarr

    def __len__(self):
        """ Get the length of the SymmetricArray. 
            
            Args:
                void
            Returns:
                self.N (int): The "size" of the array, which defines the dimensions it represents (i.e. NxN).
            Raises:
                NONE 
            Notes:
                NONE         

        """    
        return self.N

    def __repr__(self):
        return "Representation of an "+str(self.N)+"x"+str(self.N)+" array where array[i,j] = array[j,i] with "+str(self.unique)+" unique values."
    
    def __str__(self):
        return "Representation of an "+str(self.N)+"x"+str(self.N)+" array where array[i,j] = array[j,i] with "+str(self.unique)+" unique values."


    
#this array class is symmetric in the first two 
# indices, i.e. the first two indices are interchangeable
# or a.getitem(i, j, k) = a.getitem(j, i, k).
#  
class SymmetricArray3d:
    """ NxNxN symmetric array object    
    An array object for the case of NxNxN array where a[i,j,k] = a[j,i,k]. An array of this
    type will have (N**3 + N**2)/2 unique values, which is a little over half the total values 
    in the full NxNxN array. This class takes advantage of this by essentially building 
    a 2d triangle matrix (the first NxN dimensions or first two indices) where each element is an array of length N
    and only stores the unique values.   
                    
    """
    def __init__(self, N, fill_function=np.zeros, *args, **kwarg):
        """ Initialization of the SymmetricArray3d object.  

            Args:
                N (int): Defines the shape of the array, i.e. NxNxN.   
                fill_function (array generator, optional): Set the array generator function to use to
                    fill the array.  The default is numpy.zeros, which will fill the array with numpy.double zeros.
                    Other options include numpy.full and numpy.random.random. Other non-numpy functions could be used,
                    but the input function must accept at least one argument, which is a length two tuple of integers
                    specifying the array shape that is constructed by fill_function.
                    Additional arguments can be passed to the fill_function via args and kwargs. 
                args (optional): Additional arguments to be passed to the fill_function
                kwargs (optional): Additional keyword arguments to be passed to the fill_function.
            
            Attributes:
                unique (int): The number of unique elements in the array.
                shape (tuple): A tuple containing the shape that this array represents. 
                    Note that this is not the true shape of the underlying structure. 
                N (int): Defines the shape of the array, i.e. NxNxN
                values (list): A list which serves as the outer structure of the triangle array
                    used to hold the unique elements. Each element of this list is an array of the type
                    generated by the fill_function. 
                sm1 (int): This is just to store N-1 which is used for key checking during indexing.
                dtype (data type): The type of the data in the array. Uses the type function
                    to get the data type after calling of fill_function is done.  
        """
        self.unique = ((N**2 + N)/2)*N
        self.shape = (N, N, N)
        self.N = N
        self.values = []
        self.sm1 = N-1
        for i in xrange(N):
                self.values.append(fill_func((N-i, N), *args, **kwargs))
        self.dtype = type(self.values[0][0, 0].dtype)

        return

    def getitem(self, keya, keyb, keyc):
        """ Get the element at the indices given in the input keys.
            This function is called the builtin __getitem__ function. 
            
            Args:
                keya (int): The integer row index of the element.
                keyb (int): The integer column index of the element.
                keyc (int): The integer value of the third index of the element.
            Returns:
                value (self.dtype): The element in array at the given keys/indices. 
            
            Raises:
                IndexError: If the supplied indices are out of range. 
            Notes:
                Supports negative indexing. Does not support slicing.         

        """    
        if (keya > self.sm1) or (keya < -self.N):
            raise IndexError('Index '+str(keya)+' is out of range.')
            return
        elif (keyb > self.sm1) or (keyb < -self.N):
            raise IndexError('Index '+str(keyb)+' is out of range.')
            return
        elif (keyc > self.sm1) or (keyc < -self.N):
            raise IndexError('Index '+str(keyc)+' is out of range.')
            return
        if keya < 0:
            keya+=self.N
        if keyb < 0:
            keyb+=self.N
        if keyc < 0:
            keyc+=self.N
        key_arr = [keya, keyb]
        mink = min(key_arr)
        maxk = max(key_arr)
        return self.values[mink][maxk-mink][keyc]

    def setitem(self, keya, keyb, keyc, value):
        """ Set the element at the indices given in the input keys.
            This function is called by the builtin __setitem__ function. 
            
            Args:
                keya (int): The integer row index of the element.
                keyb (int): The integer column index of the element.
                keyc (int): The integer value of the third index of the element.
            Returns:
                void
            Raises:
                IndexError: If the supplied indices are out of range. 
            Notes:
                Supports negative indexing. Does not support slicing.         

        """    
        if (keya > self.sm1) or (keya < -self.N):
            raise IndexError('Index '+str(keya)+' is out of range.')
            return
        elif (keyb > self.sm1) or (keyb < -self.N):
            raise IndexError('Index '+str(keyb)+' is out of range.')
            return
        elif (keyc > self.sm1) or (keyc < -self.N):
            raise IndexError('Index '+str(keyc)+' is out of range.')
            return
        if keya < 0:
            keya+=self.N
        if keyb < 0:
            keyb+=self.N
        if keyc < 0:
            keyc+=self.N
        key_arr = [keya, keyb]
        mink = min(key_arr)
        maxk = max(key_arr)
        self.values[mink][maxk-mink][keyc] = value
        return


    def __getitem__(self, keys):
        """ Get the element at the indices given in the input keys tuple.
            This function is calls the non-builtin getitem function. 
            
            Args:
                keys (tuple of int): The integer row indices of the element.
                    E.g. x = symarr_a[i, j, k], or equivalently x = symarr_a[j, i, k]
            Returns:
                value (self.dtype): The element in array at the given keys/indices. 
            
            Raises:
                IndexError: If keys is not a tuple (or list) of length two, or if
                    the supplied indices are out of range. 
            Notes:
                Supports negative indexing. Does not support slicing.         

        """    
        if not (isinstance(keys, tuple) or isinstance(keys, list)):
            raise IndexError('Index '+str(keys)+' has the wrong number of keys.')
            return
        elif len(keys) != 3:
            raise IndexError('Index '+str(keys)+' has the wrong number of keys.')
            return
        for key in keys:
            if (key > self.sm1):
                raise IndexError('Index '+str(key)+' is out of range.')
                return
        
        value = self.getitem(keys[0], keys[1], keys[2])
        return value
        
    def __setitem__(self, keys, value):
        """ Set the element at the indices given in the input keys tuple.
            This function ultimately calls the non-builtin setitem function. 
            
            Args:
                keys (tuple of int): A tuple of three integer indices for
                    for the element being indexed.
            Returns:
                void
            Raises:
                IndexError: If keys is not a tuple (or list) of length three, or if
                    the supplied indices are out of range. 
            Notes:
                Supports negative indexing. Does not support slicing.         

        """    
        if not (isinstance(keys, tuple) or isinstance(keys, list)):
            raise IndexError('Index '+str(keys)+' has the wrong number of keys.')
            return
        elif len(keys) != 3:
            raise IndexError('Index '+str(keys)+' has the wrong number of keys.')
            return
        for key in keys:
            if (key > self.sm1):
                raise IndexError('Index '+str(key)+' is out of range.')
                return
        self.setitem(keys[0], keys[1], keys[2], value)
        return

    #build and return the full NxNxN numpy array version
    def full_numpy(self):
        """ Get the full NxNxN numpy array from the SymmetricArray. 
            
            Args:
                void
            Returns:
                outarr (numpy.array): The full NxNxN numpy array version of this instance of SymmetricArray. 
            Raises:
                NONE 
            Notes:
                This function will only work if self.dtype is a numpy supported data type.         

        """    
        outarr = np.zeros((self.N, self.N), dtype=self.dtype)
        for i in xrange(self.N-1):
            for j in xrange(i+1, self.N):
                for k in xrange(self.N):
                    value = self[i, j, k] 
                    outarr[i][j][k] = value
                    outarr[j][i][k] = value
        return outarr

    def __len__(self):
        """ Get the length of the SymmetricArray. 
            
            Args:
                void
            Returns:
                self.N (int): The "size" of the array, which defines the dimensions it represents (i.e. NxNxN).
            Raises:
                NONE 
            Notes:
                NONE         

        """    
        return self.N

    def __repr__(self):
        return "Representation of an "+str(self.N)+"x"+str(self.N)+"x"+str(self.N)+" array where array[i,j,k] = array[j,i,k] with "+str(self.unique)+" unique values."
    
    def __str__(self):
        return "Representation of an "+str(self.N)+"x"+str(self.N)+"x"+str(self.N)+" array where array[i,j,k] = array[j,i,k] with "+str(self.unique)+" unique values."

#a simple helper function for the SymmetricArray class
def lister_1d(N, obj, init=False, *args, **kwargs): 
    """ A 1 dimensional list of objects builder. 
        
        Args:
            N (int): The length of the list containing the object obj to build.
            obj (object instance, or object initialization function): the object to store or an initialization function
                of the object to be stored.
            init (bool): Default is False: Set to True if obj is object initializer.
            args (optional): Additional arguments to be passed to obj when it is an initializer. 
            kwargs (optional): Additional keyword arguments to be passed to obj when it is an initializer.
        Returns:
            out_list (list of obj typed objects): A list the input object (or object built by) obj of length N. 
        Raises:
            NONE 
        Notes:
            For use with SymmetricArray class when a custom object is being stored in the symmetric array.         

    """
    out_list = []
    if init:
        out_list = [ obj(*args, **kwargs) for i in range(N) ]
    else:
        out_list = [ obj for i in range(N) ]
    return out_list

#a simple helper function for the SymmetricArray3d class
def lister_2d(NxM, obj, init=False, *args, **kwargs): 
    """ A 2 dimensional list objects builder. 
        
        Args:
            NxM (tuple of int): A length two tuple of the integer lengths of the outer and inner lists 
                containing the object obj.
            obj (object instance, or object initialization function): the object to store or an initialization function
                of the object to be stored.
            init (bool): Default is False: Set to True if obj is object initializer.
            args (optional): Additional arguments to be passed to obj when it is an initializer. 
            kwargs (optional): Additional keyword arguments to be passed to obj when it is an initializer.
        Returns:
            out_list (list of obj typed objects): A list the input object (or object built by) obj of length N. 
        Raises:
            NONE 
        Notes:
            For use with SymmetricArray3d class when a custom object is being stored in the symmetric array.         

    """
    out_list = []
    N = NxM[0]
    M = NxM[1]
    if init:
        for i in xrange(N):
            inner_list = [ obj(*args, **kwargs) for j in range(M) ]
            out_list.append(inner_list)
    else:
        for i in xrange(N):
            inner_list = [ obj for j in range(M) ]
            out_list.append(inner_list)
    return out_list
